{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":[" "],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-mkdocs","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#java-crash-course","title":"Java Crash Course","text":""},{"location":"code-of-conduct/","title":"Code of conduct","text":""},{"location":"how-to-contribute/","title":"How to Contribute","text":""},{"location":"tag-index/","title":"Tag index","text":""},{"location":"atcoder/abc431/A-robot-balance/","title":"A-Robot Balance","text":""},{"location":"atcoder/abc431/A-robot-balance/#a-robot-balance","title":"A - Robot Balance","text":"<p>Takahashi ingin membuat robot dengan menggabungkan part kepala dan badan. Sebuah robot akan jatuh apabila berat dari kepala lebih berat daripada berat badanya sendiri.</p> <p>Saat ini, dia memiliki satu part kepala dan satu part badan. Berat dari kepala adaalh \\(H\\) gram dan berat dari badanya adalah \\(B\\) gram.</p> <p>Saat ini ia ingin membuat badannya lebih berat dari kepalanya supaya tidak jatuh. Cari tahu, berapa banyak gram berat yang perlu ditambah supaya kepalanya tidak lebih berat daripada badanya.</p>"},{"location":"atcoder/abc431/A-robot-balance/#sesi-death-ground","title":"Sesi Death Ground \u2694\ufe0f","text":"<p>Solusinya mudah, jika \\(H \\leq B\\), maka kita hanya perlu mengoutputkan \\(0\\). Ini karena berat dari part sudah memnuhi kebutuhan untuk membuat robot yang tidak akan jatuh. Sedangkan jika \\(H &gt; B\\), maka cukup outputkan \\(H-B\\) untuk mendapatkan berat yang perlu ditambah terhadap \\(B\\) supaya robot yang dibuat memiliki berat part yang sesuai.</p> <pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nauto main() -&gt; int {\n    int h, b;\n    cin &gt;&gt; h &gt;&gt; b;\n    cout &lt;&lt; (h &gt; b ? h-b : 0);\n    return 0;\n}\n</code></pre>"},{"location":"atcoder/abc431/A-robot-balance/#jawaban-dan-editorial","title":"Jawaban dan Editorial","text":"<p>Masalah ini dapat diselesaikan dengan mengimplementasikan proses berikut:</p> <ul> <li>Jika \\(H \\leq B\\), cetak \\(0\\).</li> <li>Jika tidak, cetak \\(H \u2212 B\\).</li> </ul> <p>Proses tersebut dapat diimplementasikan menggunakan pernyataan <code>if</code>, atau dengan fungsi <code>max</code> setelah melakukan sedikit transformasi pada ekspresinya.</p> <p>Berikut contoh kode.</p>"},{"location":"atcoder/abc431/A-robot-balance/#contoh-kode-menggunakan-if-statement","title":"Contoh kode menggunakan <code>if</code> statement","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint main() {\n    int H, B;\n    cin &gt;&gt; H &gt;&gt; B;\n    if (H &lt;= B) { // Jika head weight lebih kecil atau sama dengan body weight,\n        cout &lt;&lt; 0 &lt;&lt; endl; // cetak 0\n    } else { // Jika tidak,\n        cout &lt;&lt; H - B &lt;&lt; endl; // cetak H - B\n    }\n    return 0;\n}\n</code></pre> <pre><code>H, B = map(int, input().split())\nif H &lt;= B: # Jika head weight lebih kecil atau sama dengan body weight,\n    print(0) # cetak 0\nelse: # Jika tidak,\n    print(H - B) # cetak H - B\n</code></pre>"},{"location":"atcoder/abc431/A-robot-balance/#contoh-kode-menggunakan-fungsi-max","title":"Contoh kode menggunakan fungsi <code>max</code>","text":"<p>Proses di atas dapat dinyatakan ulang sebagai berikut:</p> <ul> <li>Cetak \\(B - B\\) jika \\(H \u2264 B\\).</li> <li>Cetak \\(H - B\\) jika tidak.</li> </ul> <p>Dengan kata lain, tugasnya adalah:</p> <p>mencetak <code>max(H, B) \u2212 B</code>.</p> <p>Masalah ini dapat diselesaikan dengan menerapkan ekspresi tersebut.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint main() {\n    int H, B;\n    cin &gt;&gt; H &gt;&gt; B;\n    cout &lt;&lt; max(H, B) - B &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <pre><code>H, B = map(int, input().split())\nprint(max(H, B) - B)\n</code></pre>"},{"location":"atcoder/abc431/B-robot-weigt/","title":"B-Robot Weigt","text":""},{"location":"atcoder/abc431/B-robot-weigt/#b-robot-weight","title":"B - Robot Weight","text":"<p>Terdapat robot, yang awalnya memiliki berat \\(X\\). Robot ini memiliki \\(N\\) part yang dapat dipasang secara simulatan sebanyak \\(N\\) tipe. Bobot dari setiap \\(N_i\\) part adalah adalah \\(W_i\\). Pada awalnya, tidak ada part yang terpasang.</p> <p>Akan dilakukan proses sebanyak \\(Q\\) query. Dimana \\(Q_i\\) merepresentasikan: - Jika part ke \\(Q_i\\) tidak terpasang, maka lakukan pemasangan. Tapi jika sudah dipasang, maka lepas part tersebut.</p> <p>Tentukan berat robot setealh melakukan semua query tersebut.</p>"},{"location":"atcoder/abc431/B-robot-weigt/#sesi-death-ground","title":"Sesi Death Ground \u2694\ufe0f","text":"<p>Menurutku solusinya mudah, kita hanya perlu menandai setiap part sebagai sudah diambil atau belum, dengan menyimpan berat dari setiap part dengan status boolean, misal dengan menggunakan vector + pair.</p> <p>Gunakan array 1-based index, dan gunakan \\(Q_i\\) sebagai pengakses part. Jika part terpasng, maka lepas, dan kurangi berat. Jika tidak terpasang, maka lakukan pemasangan, dan tambah beratnya.</p> <pre><code>#include&lt;iostream&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nauto main() -&gt; int {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int sum;\n    cin &gt;&gt; sum;\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;pair&lt;int, int&gt;&gt; at(n+1);\n    for (int i=1; i&lt;=n; i++) {\n        cin &gt;&gt; at[i].first;\n        at[i].second = 0;\n    }\n\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        int y;\n        cin &gt;&gt; y;\n        if (at[y].second) {\n            sum -= at[y].first;\n            cout &lt;&lt; sum &lt;&lt; '\\n';\n            at[y].second = 0;\n        } else {\n            sum += at[y].first;\n            at[y].second = 1;\n            cout &lt;&lt; sum &lt;&lt; '\\n';\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"atcoder/abc431/B-robot-weigt/#jawaban-dan-editorial","title":"Jawaban dan Editorial","text":"<p>Jika kita dapat mengelola status setiap jenis bagian apakah terpasang pada robot atau tidak, maka kita dapat memproses setiap query dengan memperbarui informasi tersebut sambil menghitung total berat berdasarkan informasi itu.</p> <p>Untuk mengelola \\(N\\) buah status berupa \u201cterpasang/tidak terpasang,\u201d kita dapat menggunakan fitur bahasa pemrograman seperti array atau list.</p> <p>Berikut ini adalah contoh kode programnya.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace std;\n    int X, N;\n    cin &gt;&gt; X &gt;&gt; N;\n    vector&lt;int&gt; W(N);\n    for (auto&amp;&amp; w : W)\n        cin &gt;&gt; w;\n    vector&lt;bool&gt; b(N); // b[i] := true if part i is attached; false otherwise\n\n    int Q;\n    cin &gt;&gt; Q;\n    for (int q = 0; q &lt; Q; ++q) {\n        int P;\n        cin &gt;&gt; P;\n        --P;\n        if (b[P]) { // If attached,\n            b[P] = false; // detach it\n        } else { // If detached\n            b[P] = true; // attach it\n        }\n\n        // Find the weight\n        int weight = X;\n        for (int i = 0; i &lt; N; ++i) {\n            if (b[i]) { // If part i is attached,\n                weight += W[i]; // add the weight\n            }\n        }\n        cout &lt;&lt; weight &lt;&lt; endl;\n        // Or one may `#include &lt;numeric&gt;` and write:\n        // cout &lt;&lt; transform_reduce(begin(W), end(W), begin(b), X) &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"atcoder/abc431/template/","title":"Kode - Soal","text":""},{"location":"atcoder/abc431/template/#kode-soal","title":"Kode - Soal","text":""},{"location":"atcoder/abc431/template/#1-judul","title":"1 | Judul","text":""},{"location":"atcoder/abc431/template/#2-sesi-death-ground","title":"2 | Sesi Death Ground \u2694\ufe0f","text":""},{"location":"atcoder/abc431/template/#3-jawaban-dan-editorial","title":"3 | Jawaban dan Editorial","text":""},{"location":"codeforces/1559C-mocha-and-hiking/","title":"1559C-Mocha and Hiking","text":"<pre><code>title:\u2694\ufe0f Teori Death Ground\n</code></pre>","tags":["constructive-algorithms","graphs"]},{"location":"codeforces/1559C-mocha-and-hiking/#1-mocha-and-hiking","title":"1 | Mocha and Hiking","text":"<p>Kota tempat Mocha tinggal bernama Zhijiang. Di kota tersebut terdapat \\(n+1\\) desa dan \\(2n\u22121\\) jalan satu arah.</p> <p>Terdapat dua jenis jalan:</p> <ol> <li> <p>Sebanyak \\(n\u22121\\) jalan menghubungkan desa \\(i\\) ke desa \\(i+1\\), untuk setiap \\(1\u2264i\u2264n\u22121\\).</p> </li> <li> <p>Sebanyak \\(n\\) jalan lain dijelaskan menggunakan suatu deret \\(a1,\u2026,an\\).  Jika \\(a_i=0\\), maka jalan ke-\\(i\\) menghubungkan desa \\(i\\) ke desa \\(n+1\\). Jika \\(a_i=1\\), maka jalan tersebut menghubungkan desa \\(n+1\\) ke desa \\(i\\).</p> </li> </ol> <p>Mocha berencana pergi hiking bersama Taki akhir pekan ini. Agar perjalanan tidak membosankan, mereka ingin melalui setiap desa tepat satu kali. Mereka boleh memulai dan mengakhiri di desa mana pun. Bisakah kamu membantu mereka menentukan rute perjalanan tersebut?</p> <p>Input</p> <p>Setiap input terdiri dari beberapa test case.</p> <p>Baris pertama berisi sebuah bilangan bulat \\(t\\) \\((1\u2264t\u226420)\\) \u2014 banyaknya test case. Setiap test case terdiri dari dua baris:</p> <p>Baris pertama berisi sebuah integer \\(n (1\u2264n\u226410^4)\\) \u2014 menandakan bahwa jumlah desa adalah \\(n+1\\).</p> <p>Baris kedua berisi \\(n\\) bilangan: \\(a_1,a_2,\u2026,a_n (0\u2264a_i\u22641)\\). Jika \\(a_i=0\\), berarti terdapat jalan dari desa \\(i\\) menuju desa \\(n+1\\). Jika \\(a_i=1\\), berarti terdapat jalan dari desa \\(n+1\\) menuju desa \\(i\\).</p> <p>Dijamin bahwa jumlah seluruh \\(n\\) pada semua test case tidak melebihi \\(10^4\\).</p> <p>Output</p> <p>Untuk setiap test case, cetak satu baris berisi \\(n+1\\) bilangan, di mana bilangan ke-\\(i\\) menunjukkan desa yang dikunjungi pada urutan ke-\\(i\\).</p> <p>Jika tidak ada rute yang valid, cetak \\(-1\\).</p> <p>Jika terdapat lebih dari satu jawaban yang benar, boleh mencetak salah satunya.</p> <p></p>","tags":["constructive-algorithms","graphs"]},{"location":"codeforces/1559C-mocha-and-hiking/#2-sesi-death-ground","title":"2 | Sesi Death Ground \u2694\ufe0f","text":"<p>Aku tidak tahu bagaimana cara menyelesaikanya, mari kita bedah.</p> <p></p>","tags":["constructive-algorithms","graphs"]},{"location":"codeforces/1559C-mocha-and-hiking/#3-jawaban-dan-editorial","title":"3 | Jawaban dan Editorial","text":"","tags":["constructive-algorithms","graphs"]},{"location":"codeforces/1559C-mocha-and-hiking/#31-analisis-official","title":"3.1 | Analisis Official","text":"<p>Jika \\(a_1 = 1\\), maka lintasan \\(\\left[(n+1) \\to 1 \\to 2 \\to \\cdots \\to n \\right]\\) valid.</p> <p>Jika \\(a_n = 0\\), maka lintasan \\(\\left[1 \\to 2 \\to \\cdots \\to n \\to (n+1)\\right]\\) valid.</p> <p>Jika bukan keduanya, karena \\(a_1 = 0 \\land a_n = 1\\), maka pasti terdapat sebuah bilangan bulat \\(i\\) dengan \\(1 \\le i &lt; n\\) sehingga \\(a_i = 0 \\land a_{i+1} = 1\\). Pada kasus ini, lintasan:</p> \\[\\left[1 \\to 2 \\to \\cdots \\to i \\to (n+1) \\to (i+1) \\to (i+2) \\to \\cdots \\to n \\right]\\] <p>adalah valid.</p> <p>Ini merupakan langkah untuk membuktikan bahwa selalu ada sebuah lintasan Hamiltonian di dalam sebuah tournament graph.</p> <p>Editorial:</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; a(n);\n    for(int i = 0; i &lt; n; i++){\n        cin &gt;&gt; a[i];\n    }\n\n    // Case 1: a1 = 1 \u2192 path: (n+1) \u2192 1 \u2192 2 \u2192 ... \u2192 n\n    if(a[0] == 1){\n        cout &lt;&lt; n + 1 &lt;&lt; \" \";\n        for(int i = 1; i &lt;= n; i++){\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n        return;\n    }\n\n    // Case 2: find position where ai = 0 and ai+1 = 1\n    for(int i = 0; i &lt; n - 1; i++){\n        if(a[i] == 0 &amp;&amp; a[i + 1] == 1){\n            for(int j = 1; j &lt;= i + 1; j++){\n                cout &lt;&lt; j &lt;&lt; \" \";\n            }\n            cout &lt;&lt; n + 1 &lt;&lt; \" \";\n            for(int j = i + 2; j &lt;= n; j++){\n                cout &lt;&lt; j &lt;&lt; \" \";\n            }\n            return;\n        }\n    }\n\n    // Case 3: an = 0 \u2192 path: 1 \u2192 2 \u2192 ... \u2192 n \u2192 (n+1)\n    for(int i = 1; i &lt;= n; i++){\n        cout &lt;&lt; i &lt;&lt; \" \";\n    }\n    cout &lt;&lt; n + 1 &lt;&lt; \" \";\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin &gt;&gt; t;\n    while(t--){\n        solve();\n        cout &lt;&lt; \"\\n\";\n    }\n    return 0;\n}\n</code></pre>","tags":["constructive-algorithms","graphs"]},{"location":"codeforces/1559C-mocha-and-hiking/#32-analisis-pribadi","title":"3.2 | Analisis Pribadi","text":"","tags":["constructive-algorithms","graphs"]},{"location":"codeforces/1559C-mocha-and-hiking/#33-analisis-jawaban-user-lain","title":"3.3 | Analisis Jawaban User Lain","text":"","tags":["constructive-algorithms","graphs"]},{"location":"codeforces/1559C-mocha-and-hiking/#1-jawaban-pertama","title":"1 | Jawaban Pertama","text":"","tags":["constructive-algorithms","graphs"]},{"location":"codeforces/1559C-mocha-and-hiking/#2-jawaban-kedua","title":"2 | Jawaban Kedua","text":"","tags":["constructive-algorithms","graphs"]},{"location":"codeforces/1559C-mocha-and-hiking/#3-jawaban-ketiga","title":"3 | Jawaban Ketiga","text":"","tags":["constructive-algorithms","graphs"]},{"location":"codeforces/1996C-Sort/","title":"1996C-Sort","text":"<pre><code>title:\u2694\ufe0f Teori Death Ground\n</code></pre>","tags":["dynamic-programming","greedy","sortings","string"]},{"location":"codeforces/1996C-Sort/#1-sort","title":"1 | Sort","text":"<p>Batas waktu per uji: 5 detik Batas memori per uji: 256 megabyte</p> <p>Anda diberikan dua string \\(a\\) dan \\(b\\) yang masing-masing memiliki panjang \\(n\\). Setelah itu, Anda harus menjawab \\(q\\) buah query.</p> <p>Untuk setiap query, diberikan sebuah rentang indeks dari \\(l\\) hingga \\(r\\). Dalam satu operasi, Anda dapat memilih sebuah indeks \\(i\\) dengan \\(l \\le i \\le r\\) dan mengubah \\(a_i = x\\), di mana \\(x\\) adalah karakter apa pun yang Anda inginkan.</p> <p>Tujuan Anda adalah menentukan jumlah minimum operasi yang harus dilakukan sehingga:</p> \\[\\text{sorted}(a[l..r]) = \\text{sorted}(b[l..r])\\] <p>Operasi yang dilakukan pada satu query tidak mempengaruhi query lainnya.</p> <p>Untuk sebuah string sembarang \\(c\\), \\(\\text{sorted}(c[l..r])\\) adalah substring \\(c_l, c_{l+1}, \\ldots, c_r\\) yang telah diurutkan secara leksikografis.</p> <p>Input</p> <p>Baris pertama berisi sebuah bilangan bulat \\(t\\) (\\(1 \\le t \\le 1000\\)) \u2014 jumlah test case.</p> <p>Untuk setiap test case:</p> <ul> <li>Baris pertama berisi dua bilangan bulat \\(n\\) dan \\(q\\) (\\(1 \\le n, q \\le 2 \\cdot 10^5\\)).</li> <li>Baris berikutnya berisi string \\(a\\) sepanjang \\(n\\) (hanya huruf latin kecil).</li> <li>Baris berikutnya berisi string \\(b\\) sepanjang \\(n\\) (hanya huruf latin kecil).</li> <li>Setiap dari \\(q\\) baris berikutnya berisi dua bilangan bulat \\(l\\) dan \\(r\\) (\\(1 \\le l \\le r \\le n\\)) \u2014 rentang query.</li> </ul> <p>Dijamin bahwa total nilai \\(n\\) dan \\(q\\) pada seluruh test case tidak melebihi \\(2 \\cdot 10^5\\).</p> <p>Output</p> <p>Untuk setiap query, keluarkan satu bilangan bulat \u2014 jumlah minimum operasi yang diperlukan.</p> <p>Input Output</p> <pre><code>3\n5 3\nabcde\nedcba\n1 5\n1 4\n3 3\n\n4 2\nzzde\nazbe\n1 3\n1 4\n\n6 3\nuwuwuw\nwuwuwu\n2 4\n1 3\n1 6\n</code></pre> <pre><code>0\n1\n0\n2\n2\n1\n1\n0\n</code></pre> <p></p>","tags":["dynamic-programming","greedy","sortings","string"]},{"location":"codeforces/1996C-Sort/#2-sesi-death-ground","title":"2 | Sesi Death Ground \u2694\ufe0f","text":"","tags":["dynamic-programming","greedy","sortings","string"]},{"location":"codeforces/1996C-Sort/#3-jawaban-dan-editorial","title":"3 | Jawaban dan Editorial","text":"","tags":["dynamic-programming","greedy","sortings","string"]},{"location":"codeforces/1996C-Sort/#31-analisis-official","title":"3.1 | Analisis Official","text":"<p>Agar dua string menjadi sama setelah diurutkan, keduanya harus memiliki jumlah kemunculan yang sama untuk setiap huruf alfabet kecil. Untuk menjawab query pada rentang \\([l, r]\\), kita harus memastikan bahwa setelah operasi:</p> \\[\\text{cnt}_c = \\text{cnt2}_c\\] <p>di mana \\(\\text{cnt}_c\\) adalah jumlah kemunculan karakter \\(c\\) pada substring \\(a[l..r]\\), dan \\(\\text{cnt2}_c\\) adalah jumlah kemunculan karakter yang sama pada substring \\(b[l..r]\\).</p> <p>Baik \\(\\text{cnt}_c\\) maupun \\(\\text{cnt2}_c\\) dapat dihitung menggunakan prefix sum untuk karakter \\(c\\). Karena hanya ada \\(26\\) kemungkinan karakter, maka kita dapat membuat \\(26\\) buah array prefix sum masing-masing berukuran \\(n\\).</p> <p>Dalam satu operasi, Anda dapat mengganti satu karakter \\(c\\) menjadi karakter lain \\(c_2\\). Secara konsep, operasi tersebut berarti mengurangi:</p> \\[\\text{cnt}_c \\leftarrow \\text{cnt}_c - 1\\] <p>dan menambah:</p> \\[\\text{cnt}*{c_2} \\leftarrow \\text{cnt}*{c_2} + 1\\] <p>Tentu saja, karakter yang dipilih harus memenuhi kondisi:</p> \\[\\text{cnt}_c &gt; \\text{cnt2}_c \\quad \\text{dan} \\quad \\text{cnt}_{c_2} &lt; \\text{cnt2}_{c_2}\\] <p>Sehingga, kita hanya perlu fokus pada karakter \\(c\\) (atau \\(c_2\\)) karena setiap pengurangan pada satu karakter otomatis meningkatkan karakter lainnya.</p> <p>Jawaban untuk query adalah:</p> \\[\\sum_{c='a'}^{'z'} \\max(0,, \\text{cnt}_c - \\text{cnt2}_c)\\] <p>yakni jumlah seluruh selisih surplus karakter di string \\(a\\) dibandingkan string \\(b\\) pada rentang tersebut.</p>","tags":["dynamic-programming","greedy","sortings","string"]},{"location":"codeforces/1996C-Sort/#32-analisis-pribadi","title":"3.2 | Analisis Pribadi","text":"","tags":["dynamic-programming","greedy","sortings","string"]},{"location":"codeforces/1996C-Sort/#33-analisis-jawaban-user-lain","title":"3.3 | Analisis Jawaban User Lain","text":"","tags":["dynamic-programming","greedy","sortings","string"]},{"location":"codeforces/1996C-Sort/#1-jawaban-pertama","title":"1 | Jawaban Pertama","text":"","tags":["dynamic-programming","greedy","sortings","string"]},{"location":"codeforces/1996C-Sort/#2-jawaban-kedua","title":"2 | Jawaban Kedua","text":"","tags":["dynamic-programming","greedy","sortings","string"]},{"location":"codeforces/1996C-Sort/#3-jawaban-ketiga","title":"3 | Jawaban Ketiga","text":"","tags":["dynamic-programming","greedy","sortings","string"]},{"location":"deliberate-practice/6%20Mistakes%20in%20Learning%20Competitive%20Programming/","title":"6 Mistakes in Learning Competitive Programming","text":"<p>Link Sumber: 6 Mistakes in Learning Competitive Programming - YouTube</p>","tags":["advice"]},{"location":"deliberate-practice/6%20Mistakes%20in%20Learning%20Competitive%20Programming/#6-mistakes-in-learning-competitive-programming","title":"6 Mistakes in Learning Competitive Programming","text":"<p>Halo semuanya, saya Shan dan di video ini saya akan membahas kesalahan umum yang sering dilakukan orang saat belajar pemrograman kompetitif. Kesalahan-kesalahan ini bisa sepenuhnya menghancurkan usaha Anda. Jadi, jika Anda berpikir, \"Kenapa saya sudah berusaha keras tapi tidak maju, dan tidak mendapatkan rating yang saya inginkan?\", Anda harus menonton video ini untuk melihat apakah Anda melakukan salah satu kesalahan ini. Tanpa basa-basi lagi, mari kita mulai.</p>","tags":["advice"]},{"location":"deliberate-practice/6%20Mistakes%20in%20Learning%20Competitive%20Programming/#1-menyelesaikan-masalah-secara-acak","title":"1 | Menyelesaikan Masalah secara Acak","text":"<p>Kadang saya melihat orang yang tidak tahu harus menyelesaikan masalah apa, bagaimana cara menemukan masalah yang bagus, dan mereka hanya menyelesaikan masalah acak dari sumber-sumber kode. Ini berhasil di awal, saat Anda masih pemula atau \"pupil\". Itu berhasil karena, seperti yang saya katakan, Anda bisa menyaring masalah berdasarkan tingkat kesulitannya dan mulai menyelesaikannya. Namun, seiring Anda berkembang dan rating Anda semakin tinggi, Anda harus mulai belajar menemukan masalah yang bagus.</p> <p>Ada banyak cara untuk menemukan masalah yang bagus, tetapi cara yang paling penting adalah menggunakan fitur di Codeforces. Fitur ini disebut List. Fitur ini sangat membantu Anda karena dapat menemukan masalah yang diselesaikan oleh orang-orang penting. Jadi, pada dasarnya idenya adalah Anda bisa membuat daftar orang-orang penting yang Anda kagumi, dan fitur ini akan menampilkan di depan setiap masalah berapa banyak orang dalam daftar itu yang telah menyelesaikannya. Pada dasarnya, Anda bisa menyimpulkan bahwa jika sebuah masalah diselesaikan oleh banyak orang tersebut, itu berarti masalah itu adalah masalah yang bagus dan layak untuk diselesaikan. Pendekatan ini hampir selalu berhasil.</p> <p>Anda bisa menambahkan para competitive programmer terbaik di dunia, rival Anda, atau orang-orang yang Anda kenal dan kagumi. Anda bisa melihat berapa banyak dari mereka yang telah menyelesaikan setiap masalah. Sungguh, dengan probabilitas tinggi, masalah yang diselesaikan oleh banyak orang ini adalah masalah yang sangat bagus. Jadi, jika Anda membuka Codeforces dan masuk ke profil Anda, Anda bisa klik di bagian List dan pilih Create new list. Lalu Anda bisa memilih nama untuk daftar Anda. Mari kita beri nama \"sample list\". Kemudian Anda bisa mulai menambahkan orang ke dalam daftar Anda.</p> <p>Mari kita lihat para competitive programmer dengan peringkat tertinggi dan mari kita tambahkan mereka. Misalnya, kita tambahkan tourist dan Jiangly. Lalu Anda bisa membuat daftar dengan nama-nama ini. Anda menambahkan semua orang ini ke daftar Anda, dan Anda bisa melihat bahwa mereka semua ada di sini. Sekarang Anda bisa mengurutkannya berdasarkan rating atau apa pun. Tidak harus competitive programmer teratas, Anda bisa memilih siapa saja. Mari kita ke Problem sets dan di Status, mari kita lihat orang terakhir yang telah menyelesaikan masalah. Saya akan menambahkan orang ini. Anda juga bisa menambahkan orang ini, misalnya.</p> <p>Kemudian jika Anda membuka Problem sets di sini, jika Anda klik di bagian ini, Anda bisa melihat daftar Anda. Jika saya klik \"sample list\", Anda sekarang bisa melihat bahwa di depan setiap masalah tertulis berapa banyak orang dari daftar itu yang telah menyelesaikan masalah spesifik tersebut. Anda bisa melihat semua ini dan jika Anda mencari masalah dengan rating tertentu, Anda bisa mencari masalah dengan rating misalnya 1500. Lalu Anda bisa melihat bahwa untuk setiap masalah ini, berapa banyak orang di daftar itu yang telah menyelesaikannya. Jika Anda memilih daftar ini, misalnya, saya melihat masalah ini diselesaikan oleh tujuh orang, masalah ini diselesaikan oleh 10 orang, dan seterusnya. Masalah ini diselesaikan oleh dua orang dan seterusnya.</p> <p>Namun, saya sangat, sangat merekomendasikan Anda untuk menambahkan lebih banyak orang ke dalam daftar ini. Misalnya, tambahkan 40 hingga 50 orang. Terutama, tambahkan rival Anda. Misalnya, ketika saya belajar untuk Olimpiade Nasional Informatika Iran, saya menambahkan semua orang yang menjadi rival saya ke dalam daftar ini. Dengan begitu, saya tahu masalah apa saja yang telah mereka selesaikan, dan saya hampir yakin bahwa jika begitu banyak dari mereka telah menyelesaikan masalah itu, pasti ada sesuatu yang spesial dengan masalah tersebut. Mungkin guru mereka yang memberikan masalah ini atau semacamnya. Pada dasarnya, saya yakin bahwa masalah ini adalah masalah yang bagus. Jadi, jangan hanya menyelesaikan masalah acak. Cobalah untuk menemukan masalah yang bagus. Dan menggunakan List sangat membantu Anda.</p> <p>Bahkan sekarang, ketika saya menjadi seorang guru, saat saya ingin memilih masalah yang bagus untuk orang lain\u2014masalah yang bahkan belum pernah saya lihat sendiri sebelumnya\u2014saya akan menggunakan fitur ini dan saya menemukan masalah yang telah diselesaikan oleh banyak orang ini, lalu saya membukanya. Dan saya melihat bahwa itu adalah masalah yang sangat indah dan sangat edukatif. Jadi, pastikan untuk menggunakan fitur ini.</p>","tags":["advice"]},{"location":"deliberate-practice/6%20Mistakes%20in%20Learning%20Competitive%20Programming/#2-belajar-seperti-kimia","title":"2 | Belajar seperti Kimia","text":"<p>Kadang saya melihat orang memperlakukan pemrograman kompetitif seperti kimia. Mereka mencari buku, mereka mencoba membaca berbagai algoritma. Itu sangat buruk. Ini bukan yang seharusnya Anda lakukan. Pemrograman kompetitif adalah keterampilan yang akan terbentuk melalui banyak latihan.</p> <p>Seperti yang saya katakan jutaan kali sebelumnya, Anda tidak boleh mulai dengan mencari algoritma dan hanya membacanya, menghafalnya, dan melihat apa itu. Belajar algoritma tidak terlalu penting. Kemampuan, keterampilan untuk menyelesaikan banyak masalah, itulah yang penting.</p> <p>Jadi, jika Anda melihat orang yang tahu banyak algoritma, mereka telah menghafalnya. Itu tidak berarti mereka kuat. Mereka hanya tahu banyak algoritma. Jika Anda meminta mereka untuk menulis algoritma ini, mereka bisa menuliskannya dengan sempurna untuk Anda. Tetapi mereka tidak bisa menyelesaikan masalah dengan algoritma yang paling sederhana. Itu tidak pernah bagus. Saya pernah mengajar di banyak sekolah dan saya melihat bahwa orang-orang ini masih pemula atau pupil setelah satu atau dua tahun belajar dan mengikuti kelas. Kemudian saya mulai bekerja dengan siswa-siswa ini dan selama tiga atau empat bulan mereka menjadi ahli. Ini adalah sesuatu yang telah terjadi berulang kali. Dan jika Anda bertanya kepada saya apa alasannya, apa yang saya lakukan berbeda dengan guru mereka sebelumnya. Intinya adalah saya menyadari bahwa guru sebelumnya mengajarkan mereka AVL tree. Jadi, para siswa tahu algoritma terberat, tetapi mereka tidak tahu bagaimana menyelesaikan masalah dalam sebuah kontes untuk keluar dari tahap pupil.</p> <p>Itu adalah cara paling bodoh untuk belajar pemrograman kompetitif. Dan jika Anda melakukannya, Anda akan melihat bahwa semua usaha Anda tidak membuahkan hasil. Awalnya, cobalah untuk menyelesaikan 100 hingga 200 masalah. Anda bahkan tidak perlu mempelajari algoritma apa pun. Cukup tahu beberapa dasar C++ seperti cara mencetak \"hello world\" atau cara menjumlahkan dua angka, dan kemudian mulailah menyelesaikan 100 hingga 200 masalah dengan kesulitan 800 atau kesulitan minimal. Saya sudah mengatakannya berkali-kali sebelumnya, jadi saya tidak ingin mengulanginya lagi. Pastikan untuk menonton video saya yang lain tentang hal ini, terutama video tentang apa yang tidak boleh dilakukan untuk keluar dari tahap pemula dan juga cara dari pemula menjadi ahli dalam 3 bulan di mana saya menceritakan perjalanan saya sendiri.</p> <p>Jadi, jangan pernah lupakan bahwa pemrograman kompetitif bukan tentang mengetahui apa itu algoritma, melainkan tentang keterampilan Anda untuk menyelesaikan masalah.</p>","tags":["advice"]},{"location":"deliberate-practice/6%20Mistakes%20in%20Learning%20Competitive%20Programming/#3-terlalu-memikirkan-rating","title":"3 | Terlalu Memikirkan Rating","text":"<p>Sering kali saya melihat orang yang terobsesi dengan rating. Saya bahkan terkadang melihat orang mengeluh tentang \"cheaters\" (peserta curang) yang menyebabkan mereka kehilangan beberapa rating, dan perbedaannya hanya sekitar lima poin. Obsesi terhadap rating ini benar-benar dapat merugikan Anda. Meskipun rating itu penting dan Anda harus peduli dengannya\u2014itu juga bisa menjadi motivasi bagi Anda, membantu Anda berlatih lebih baik, dan memiliki motivasi untuk berkembang\u2014terlalu memikirkannya dan terobsesi dengannya dapat benar-benar merugikan Anda.</p> <p>Pada akhirnya, tidak terlalu penting berapa rating Anda saat ini. Jika level Anda lebih tinggi, cepat atau lambat Anda akan mencapai rating itu. Saya sangat menyarankan Anda untuk fokus pada pekerjaan Anda sendiri. Jangan terobsesi seperti, \"Ya ampun, kenapa rating saya turun?\" dan semacamnya. Sebaliknya, fokuslah pada pelatihan Anda. Fokuslah pada masukan Anda (input), bukan pada keluarannya (output).</p> <p>Masukan Anda adalah seberapa banyak Anda mencoba, seberapa banyak usaha yang Anda curahkan, dan lain-lain. Keluaran adalah rating yang Anda dapatkan. Anda tidak memiliki kendali atas keluarannya. Anda harus fokus pada masukan Anda. Buatlah rencana untuk masukan Anda. Misalnya, rencanakan bahwa selama sebulan ke depan, saya akan menghabiskan waktu sebanyak ini untuk berlatih. Jangan berencana seperti, \"Oke, setelah sebulan rating saya akan mencapai ini.\" Anda tidak memiliki kendali atas hal itu.</p> <p>Fokuslah pada masukan Anda. Peduli pada rating Anda, itu penting dan juga sangat menyenangkan dan kompetitif. Tapi jangan terobsesi dengannya.</p> <p>Kesalahan lain yang sangat buruk yang saya lihat dari orang adalah kadang mereka tidak berpartisipasi dalam kontes Codeforces karena mereka tidak ingin kehilangan rating, atau bahkan di awal mereka tidak memiliki keberanian untuk mulai berpartisipasi dalam kontes. Itu lagi-lagi di mana obsesi dengan rating merugikan Anda. Pastikan untuk berpartisipasi dalam semua kontes CF yang Anda bisa. Jangan lewatkan satu pun kontes selama Anda bisa. Saya harus memasukkan kembali bagian dari wawancara dengan Kavi di sini karena itu sangat penting. Dia berkata, \"Apa perbedaan yang kamu lakukan dibandingkan dengan orang lain yang kamu yakini memiliki efek signifikan pada peningkatanmu?\"</p> <p>Kavi menjawab, \"Saya selalu berusaha untuk tidak pernah melewatkan kontes di Codeforces. Tidak pernah melewatkan kontes. Saya tidak melewatkan satu pun kontes di tahun 2018 dan 2019.\"</p> <p>\"Wow! Kenapa? Bagaimana bisa?\"</p> <p>\"Karena saya sangat menikmatinya. Apakah kamu melewatkan janji kencan dengan kekasihmu? Tidak. Tidak.\"</p> <p>Jadi, berpartisipasi dalam kontes sangat penting untuk kalian. Jangan takut akan hal itu. Di tahap mana pun Anda berada, bahkan jika Anda baru saja memulai dan hanya menerima 10 masalah, saya tetap merekomendasikan Anda untuk berpartisipasi dalam kontes. Pada akhirnya, Anda ingin mendapatkan pekerjaan atau tampil baik di IOI atau ICPC. Jadi, keterampilan Anda penting. Apa yang Anda pelajari dari kontes ini jauh lebih penting daripada rating Anda. Jadi, jangan terobsesi.</p>","tags":["advice"]},{"location":"deliberate-practice/6%20Mistakes%20in%20Learning%20Competitive%20Programming/#4-mengisolasi-diri","title":"4 | Mengisolasi Diri","text":"<p>Kesalahan lain yang saya lihat orang lakukan adalah mengisolasi diri dari semua orang lain yang sedang belajar CP (pemrograman kompetitif). Itu sangat buruk.</p> <p>Mari saya mulai dengan cerita dari diri saya sendiri. Ketika saya masih di SMA dan mulai belajar pemrograman kompetitif, saya bertaruh dengan salah satu teman saya bahwa dalam waktu sekitar sebulan saya akan mendapatkan 100 accept di Codeforces\u2014mungkin sedikit lebih atau kurang, tapi sekitar itu. Dia berkata, \"Tidak, kamu tidak bisa melakukannya,\" dan saya berkata, \"Ya, saya pasti akan melakukannya,\" dan kami bertaruh. Saya menghitung bahwa saya membutuhkan sekitar empat accept per hari untuk memastikan saya mendapatkan sebanyak itu. Dan Anda tahu, motivasi tambahan ini sangat membantu saya dan membuat segalanya jauh lebih menyenangkan. Hasilnya, saya menyelesaikan jauh lebih dari empat masalah sehari. Saya menyelesaikan sekitar 8, 9, 10 masalah setiap hari, dan rating saya juga mulai tumbuh pesat. Seperti yang juga saya katakan di video saya tentang cara dari pemula menjadi ahli dalam 3 bulan.</p> <p>Jadi, intinya adalah jika Anda mengisolasi diri dari orang lain yang belajar pemrograman kompetitif, itu bisa menjadi lebih membosankan bagi Anda untuk belajar pemrograman kompetitif, sementara berinteraksi dengan orang lain yang melakukan hal yang sama dapat membuat segalanya menyenangkan. Jadi, pastikan Anda berinteraksi dengan orang lain. Jika Anda memiliki beberapa orang lain di sekolah, di universitas, atau orang-orang di sekitar Anda yang melakukan hal yang sama, berinteraksi dengan mereka akan sangat bagus. Jika tidak, setidaknya bergabunglah dengan komunitas. Misalnya, kami sendiri memiliki komunitas di Telegram dan Discord yang bisa kalian ikuti dan berbicara satu sama lain. Ada ribuan orang yang belajar pemrograman kompetitif di sana, dan akan sangat bagus jika Anda bergabung di sana dan berinteraksi dengan orang lain. Dan saya sangat merekomendasikan itu kepada semua orang. Jangan mengisolasi diri.</p>","tags":["advice"]},{"location":"deliberate-practice/6%20Mistakes%20in%20Learning%20Competitive%20Programming/#5-berpikir-kurang-atau-lebih-dari-yang-seharusnya","title":"5 | Berpikir Kurang atau Lebih dari yang Seharusnya","text":"<p>Kesalahan besar lain yang biasanya dilakukan orang\u2014dan saya sendiri membuat kesalahan ini di berbagai periode\u2014adalah berpikir tentang masalah kurang atau lebih dari yang seharusnya.</p> <p>Mari kita buat ini sederhana dan jelas. Sebagai aturan praktis, Anda harus terus memikirkan sebuah masalah selama Anda masih merasa ada hal-hal yang bisa Anda pikirkan. Ketika Anda merasa buntu, tidak apa-apa untuk membuka editorial, mungkin membaca baris pertama, lalu melanjutkan berpikir.</p> <p>Saya telah melakukan banyak wawancara dengan para competitive programmer hebat, dengan Raina, Um_nik, dan orang lain yang juga mengatakan hal yang sama. Bukan seperti, \"Tidak, kamu tidak boleh membaca solusi masalah.\" Kami pernah punya guru yang mengatakan ini kepada kami, \"Kamu tidak boleh membaca solusi masalah. Teruslah berpikir tanpa batas.\" Tetapi itu tidak bagus karena mungkin Anda akan menghabiskan begitu banyak waktu pada satu masalah, padahal dalam waktu itu Anda bisa menjelajahi lebih banyak ide.</p> <p>Juga sangat tidak benar jika Anda mulai membaca masalah dan langsung pergi dan membaca editorialnya. Saya yakin ini adalah sesuatu yang Anda rasakan sendiri. Tidak baik untuk menetapkan batas waktu. Itu adalah sesuatu yang Anda rasakan sendiri\u2014ketika Anda tidak memiliki ide sama sekali, misalnya selama 10 menit terakhir, Anda tidak ada kemajuan dan Anda tidak memiliki ide apa pun tentangnya. Dalam kasus itu, tidak apa-apa untuk mulai membaca editorial. Dan yang saya rekomendasikan adalah membaca baris pertama atau dua baris pertama dari editorial dan melihat apakah itu memberi Anda ide untuk berpikir lebih lanjut. Jika ya, lanjutkan berpikir setelah itu. Jangan langsung membaca seluruh editorialnya.</p> <p>Jadi, selalu ingat ini. Jangan berpikir lebih dari yang dibutuhkan atau kurang dari yang dibutuhkan.</p>","tags":["advice"]},{"location":"deliberate-practice/6%20Mistakes%20in%20Learning%20Competitive%20Programming/#6-malas-dan-mencari-jalan-pintas-hacks","title":"6 | Malas dan Mencari Jalan Pintas (Hacks)","text":"<p>Kadang yang saya lihat pada orang adalah mereka mencari cara mudah untuk menjadi hebat, untuk menjadi grandmaster, untuk mendapatkan warna merah dengan sangat mudah. Itu tidak pernah mungkin.</p> <p>Semua tips yang saya berikan kepada Anda ini adalah cara untuk tidak menyia-nyiakan usaha Anda. Tapi tetap saja, Anda harus berusaha. Berusaha, tetapi dengan cara yang benar. Bukan seperti, \"Oke, ada cara di mana saya tidak perlu berusaha dan saya akan menjadi hebat dalam pemrograman kompetitif.\" Tidak. Bagaimanapun, pada akhirnya, Anda harus menginvestasikan banyak waktu untuk berlatih agar menjadi lebih baik. Saya sendiri berlatih sangat keras selama lebih dari 2 atau 3 tahun untuk mencapai international grandmaster untuk pertama kalinya. Jadi, tidak seperti, \"Oke, dalam 3 bulan saya bisa menjadi IGM.\" Tidak, itu tidak mungkin. Anda pasti harus mengerahkan banyak usaha. Tidak ada jalan pintas yang mudah seperti \"jika saya melakukan ini, saya bisa melakukannya dengan mudah atau sangat cepat.\" Tidak ada yang seperti itu.</p> <p>Tonton bagian lucu dari wawancara saya dengan Um_nik ini. \"Setelah sekitar 2 tahun kamu menjadi Red coder. Jadi, dan kamu bilang semua orang bisa menjadi grandmaster. Jadi, apa metode latihanmu saat itu agar orang lain juga bisa melakukannya dan mungkin mereka juga bisa mencapai grandmaster?\"</p> <p>Um_nik menjawab, \"Saya menyelesaikan banyak masalah dan hanya itu saja.\"</p>","tags":["advice"]},{"location":"deliberate-practice/From%20Newbie%20to%20Expert%20in%203%20Months%20-%20100%25%20works%21/","title":"From Newbie to Expert in 3 Months   100% works!","text":"<p>Link Sumber: From Newbie to Expert in 3 Months | 100% works! - YouTube</p>","tags":["advice"]},{"location":"deliberate-practice/From%20Newbie%20to%20Expert%20in%203%20Months%20-%20100%25%20works%21/#from-newbie-to-expert-in-3-months-100-works","title":"From Newbie to Expert in 3 Months | 100% works!","text":"<p>Halo semuanya, saya Shayan, dan di video ini saya ingin berbicara tentang cara untuk menjadi Expert di Codeforces. Jika Anda belum mengenal saya, nama saya Shayan, seorang IGM di Codeforces dan juga finalis dunia ICPC.</p> <p>Mengapa saya orang yang tepat untuk menceritakan ini? Jika Anda melihat akun saya di Codeforces, \"Shayan\", Anda akan melihat bahwa dalam waktu singkat, dari Maret 2015 hingga Juni 2015, saya mengalami peningkatan besar dan naik dari newbie menjadi expert. Dan hari ini, saya ingin berbagi dengan Anda apa yang sebenarnya saya lakukan dan bagaimana Anda bisa melakukannya juga. Ini adalah sesuatu yang selalu saya sampaikan kepada siswa-siswa saya, jadi ambil pulpen dan kertas, catat poin-poin ini karena ini akan sangat membantu Anda.</p> <p>Mari kita mulai.</p>","tags":["advice"]},{"location":"deliberate-practice/From%20Newbie%20to%20Expert%20in%203%20Months%20-%20100%25%20works%21/#1-selesaikan-masalah-sesuai-dengan-rating-anda","title":"1 | Selesaikan Masalah Sesuai dengan Rating Anda","text":"<p>Anda tahu bahwa jika Anda menyelesaikan masalah yang sangat mudah, itu tidak akan banyak membantu Anda untuk berkembang. Dan jika Anda menyelesaikan masalah yang sangat sulit, itu akan memakan banyak waktu, dan Anda tidak akan bisa menyelesaikan banyak masalah. Saya yakin untuk menjadi expert, Anda perlu menyelesaikan banyak masalah.</p> <p>Saya sendiri menyelesaikan sekitar 10 masalah sehari. Jika Anda melihat akun saya, Anda bisa melihat bahwa pada periode itu, saya menyelesaikan sekitar 10 masalah sehari, dan karena itu, masalahnya tidak terlalu sulit. Bahkan berpikir dan membuang waktu pada masalah pun akan sangat membantu di masa depan, tetapi karena Anda baru memulai dan ingin mencapai expert, saya yakin pada periode ini, strategi terbaik bagi Anda adalah menyelesaikan masalah di sekitar rating Anda sehingga Anda bisa menyelesaikan sekitar 10 masalah per hari.</p> <p>Saya percaya masalah-masalah ini harus memiliki tingkat kesulitan di mana Anda menghabiskan rata-rata sekitar setengah jam untuk menyelesaikannya. </p> <p>\"Dulu, Codeforces tidak memiliki tingkat kesulitan untuk masalah. Jadi, saya mengurutkan masalah berdasarkan jumlah orang yang menyelesaikannya dan saya menyelesaikan lima halaman pertama dari problem set yang diurutkan berdasarkan jumlah accepted.\"</p> <p>\"Itu benar-benar pendekatan terbaik. Saya selalu menyuruh para pemula, siswa-siswa saya, untuk melakukan ini terlebih dahulu.\"</p> <p>\"Saya selalu menyuruh mereka untuk menyelesaikan 400 masalah termudah terlebih dahulu, dan baru setelah itu kita akan membicarakan hal lain. Jangan mulai belajar struktur data yang rumit, dll. Cukup selesaikan masalah implementasi, masalah brute force, ya, matematika, itu adalah pendekatan terbaik.\" </p> <p>Misalnya, jika rating Anda saat ini 1200, saya yakin tingkat kesulitan terbaik untuk Anda adalah sekitar 1200. Seperti yang saya katakan, alasan di baliknya adalah Anda perlu menyelesaikan banyak masalah.</p> <p>Jika Anda menyelesaikan masalah yang sangat sulit, Anda harus banyak memikirkannya. Dengan menghabiskan banyak waktu pada masalah yang sangat sulit, Anda akan menghabiskan banyak waktu untuk berpikir, tetapi sangat sedikit waktu untuk coding. Dan itulah mengapa setelah beberapa saat, Anda akan merasa pandai berpikir, pandai menyelesaikan masalah, tetapi tidak pandai mengimplementasikannya, dan Anda tidak bisa menyelesaikan masalah-masalah itu. Itulah mengapa saya yakin Anda harus menghabiskan waktu Anda pada masalah dengan kesulitan di sekitar rating Anda pada tahap ini. Jangan mencari masalah yang sangat mudah dan jangan mencari masalah yang lebih sulit dari level Anda saat ini.</p> <p>Beberapa orang mungkin bertanya, \"Tapi jika saya menghabiskan banyak waktu menyelesaikan masalah dengan rating saya sendiri, apakah rating saya akan meningkat?\" Ya, tentu. Ketika rating Anda berada pada titik tertentu, itu tidak berarti Anda bisa menyelesaikan dan mengimplementasikan semua masalah pada rating itu. Mungkin pada beberapa topik (tags) Anda lebih baik, dan pada beberapa topik lain Anda lebih buruk. Intinya adalah ketika Anda menyelesaikan masalah di sekitar rating itu, Anda juga akan menemukan kelemahan Anda. Anda akan melihat, dari rating Anda sendiri, topik apa yang tidak begitu bagus, dan Anda akan bisa menyelesaikan masalah-masalah itu juga.</p>","tags":["advice"]},{"location":"deliberate-practice/From%20Newbie%20to%20Expert%20in%203%20Months%20-%20100%25%20works%21/#2-jangan-mengganggu-diri-dengan-materi-yang-tidak-relevan","title":"2 | Jangan Mengganggu Diri dengan Materi yang Tidak Relevan","text":"<p>Jika Anda telah menonton dua video saya yang lain tentang cara keluar dari newbie, Anda akan melihat bahwa saya mengatakan Anda tidak boleh mempelajari struktur data yang sangat kompleks seperti segment tree, centroid, dll. saat Anda masih newbie. Itu selalu benar, tetapi satu-satunya perbedaan adalah, sekarang Anda ingin mencapai expert, Anda harus mengerjakan lebih banyak topik. Tetapi masih ada topik yang tidak perlu Anda pelajari banyak.</p> <p>Misalnya, saya masih yakin struktur data yang kompleks tidak diperlukan. Sebaliknya, Anda harus fokus pada hal lain yang akan saya ceritakan pada poin berikutnya. Jadi, intinya adalah materi yang tidak relevan bukan hanya materi yang tidak berguna dan tidak akan pernah muncul di kontes pemrograman kompetitif, tetapi juga materi yang lebih sulit dari yang Anda butuhkan. Kadang saya melihat orang yang ingin menjadi expert menghabiskan waktu mereka untuk mempelajari persistent segment tree. Itu bodoh. Anda tidak boleh melakukannya. Jadi, fokuslah pada pemecahan masalah di sekitar rating Anda. Jangan menghabiskan waktu untuk mempelajari algoritma yang sangat sulit.</p>","tags":["advice"]},{"location":"deliberate-practice/From%20Newbie%20to%20Expert%20in%203%20Months%20-%20100%25%20works%21/#3-dp-dp-dan-dp","title":"3 | DP, DP, dan DP","text":"<p>Salah satu topik terpenting dalam pemrograman kompetitif adalah pemrograman dinamis (dynamic programming). Anda harus menghabiskan banyak waktu untuk itu, terutama saat Anda ingin menjadi expert. Itu adalah waktu di mana Anda harus menghabiskan banyak waktu pada pemrograman dinamis. Jadi, cobalah untuk banyak mengerjakan pemrograman dinamis, berbagai cara pemrograman dinamis, dll.</p> <p>Jika Anda telah menonton topic streams saya dan belajar secara mendalam dari saya, Anda tahu bahwa pemrograman dinamis memiliki empat fase berbeda yang harus Anda perhatikan, dan saya telah memberitahu Anda bagaimana cara mendekati masalah pemrograman dinamis. Jadi, pastikan Anda benar-benar menguasainya dan telah memahaminya, dan cobalah untuk menyelesaikan banyak masalah dari pemrograman dinamis juga. Dan masalah-masalah yang saya ceritakan tadi, yang harus Anda selesaikan 10 masalah sehari, juga termasuk masalah pemrograman dinamis. Jadi, selain menyelesaikan masalah tanpa tag di sekitar rating Anda yang sangat membantu, cobalah juga untuk menyelesaikan masalah dengan tag pemrograman dinamis.</p>","tags":["advice"]},{"location":"deliberate-practice/From%20Newbie%20to%20Expert%20in%203%20Months%20-%20100%25%20works%21/#4-tonton-topic-streams","title":"4 | Tonton Topic Streams","text":"<p>Saya telah menyiapkan banyak topic streams gratis untuk Anda di mana saya telah memberi tahu Anda cara mendekati berbagai topik seperti pemrograman dinamis, teori graf, teori bilangan, dll. Itu sepenuhnya gratis dan dirancang untuk orang-orang seperti Anda. Jadi, saya sangat merekomendasikan Anda untuk menontonnya untuk benar-benar memahami dan mempelajari topik-topik ini. Saya akan menaruh tautannya di deskripsi di bawah ini, jadi Anda bisa menontonnya dan mulai belajar dari sana.</p> <p>Setelah menonton video di mana saya telah mempelajari topik tersebut, misalnya katakanlah pemrograman dinamis, tonton juga video di mana saya menyelesaikan masalah di dalamnya. Jadi, pastikan Anda menggunakan materi ini, terutama jika Anda tidak memiliki guru saat ini atau Anda tidak terlalu puas dengan guru Anda saat ini.</p>","tags":["advice"]},{"location":"deliberate-practice/From%20Newbie%20to%20Expert%20in%203%20Months%20-%20100%25%20works%21/#5-berpikir-sesuai-kebutuhan","title":"5 | Berpikir Sesuai Kebutuhan","text":"<p>Jadi, pertanyaan yang sangat penting adalah seberapa banyak Anda harus memikirkan sebuah masalah? Saya juga telah bertanya tentang hal ini kepada banyak competitive programmer hebat yang bisa Anda lihat di wawancara saya, seperti saya bertanya pada Um_nik dan Rina serta banyak orang lain. Kami semua sepakat pada hal yang sama: Anda harus menghabiskan waktu selama Anda tidak buntu. Jika Anda masih merasa memiliki ide untuk menyelesaikan masalah, Anda harus terus memikirkannya. Jangan langsung melihat solusi masalahnya.</p> <p>Tetapi saya dan orang-orang yang saya wawancarai percaya bahwa, terutama pada tahap ini, ketika Anda merasa buntu, tidak apa-apa jika Anda melihat editorial. Misalnya, baca baris pertama dan lihat apa yang dikatakannya. Dapatkan petunjuk darinya dan lanjutkan berpikir. Dan bahkan jika itu tidak cukup bagi Anda, Anda bisa terus membaca untuk melihat apa solusinya.</p> <p>Selalu ada masalah yang belum Anda selesaikan, dan saya tidak berpikir Anda harus langsung melihat solusinya, Anda harus melihat solusinya. Jadi, bagaimana menurut Anda kita harus mendekati masalah? Maksud saya, berapa lama Anda harus berpikir sebelum mulai melihat solusi?</p> <p>Um_nik menjawab, \"Saya rasa jika Anda merasa perlu tahu sesuatu yang tidak Anda ketahui, mungkin seperti mulai membaca baris demi baris dan berpikir. Tapi sebagai aturan umum, Anda harus mencoba melihat masalah dari ujung ke ujung, membacanya sedikit demi sedikit di editorial dan berpikir lagi.\"</p>","tags":["advice"]},{"location":"deliberate-practice/From%20Newbie%20to%20Expert%20in%203%20Months%20-%20100%25%20works%21/#6-belajar-sendiri","title":"6 | Belajar Sendiri","text":"<p>Seperti yang saya katakan, Anda tidak perlu mempelajari banyak algoritma untuk menjadi expert. Anda harus menyelesaikan banyak masalah untuk menjadi expert. Itulah poin utamanya. Menyelesaikan masalah adalah hal yang penting, bukan menghafal apa itu algoritma.</p> <p>Jadi, pendekatan yang sangat saya rekomendasikan\u2014dan itulah yang saya lakukan juga\u2014adalah belajar saat Anda menyelesaikan masalah. Saya biasa melakukan ini. Saya tidak membaca editorial. Sejujurnya, di awal saya tidak tahu editorial itu ada. Saya baru di Codeforces dan saya tidak melihat tombol tutorial itu. Jadi, saya membaca kode orang lain, dan saya belajar banyak dari membaca kode orang lain. Saya belajar cara coding yang lebih baik dan saya juga belajar beberapa cara berpikir baru.</p> <p>Cara yang saya gunakan adalah dengan membuka sebuah kode dan mencoba memahami apa yang dilakukannya, dan itu membantu saya berpikir juga. Setelah beberapa saat, kadang saya menyadari bahwa itu sebenarnya sebuah algoritma. Intinya adalah saya tidak pernah mencoba mempelajari sebuah algoritma. Saya mencoba menyelesaikan masalah, dan saat saya menyelesaikannya, ketika saya melihat ada masalah yang membutuhkan sesuatu, saya mempelajarinya saat menghadapi masalah itu. Jadi, saya tidak mempelajari algoritma sebelum benar-benar menghadapi masalah yang membutuhkan algoritma itu.</p> <p>Itulah yang saya rekomendasikan juga untuk Anda. Cobalah untuk mempelajari algoritma saat Anda menyelesaikan masalah. Jangan mulai dengan belajar terlebih dahulu lalu menyelesaikan masalah. Mulai saja menyelesaikan masalah, dan Anda akan belajar. Dan topik terpenting untuk menjadi expert, seperti yang saya katakan, adalah pemrograman dinamis, algoritma greedy, teori bilangan, algoritma graf, dan masih banyak lagi topik yang saya sebutkan di video newbie, yaitu implementasi, brute force, matematika, dll.</p> <p>\"Ketika Anda memulai, Anda adalah seorang spesialis saat Anda memulai kontes di Codeforces. Setelah sekitar 2 tahun, Anda menjadi warna merah. Dan Anda mengatakan bahwa setiap orang bisa menjadi grandmaster. Jadi, apa metode latihan Anda saat itu agar orang lain juga bisa melakukannya dan mungkin mereka juga bisa mencapai grandmaster?\"</p> <p>Um_nik menjawab, \"Saya menyelesaikan banyak masalah, Anda tahu, dan itu saja.\"</p> <p>\"Berapa lama Anda menyelesaikan masalah per hari atau per minggu?\"</p> <p>\"Saya tidak ingat, tapi pada dasarnya, seluruh waktu luang saya.\"</p> <p>\"Seluruh waktu luang Anda?\"</p>","tags":["advice"]},{"location":"deliberate-practice/From%20Newbie%20to%20Expert%20in%203%20Months%20-%20100%25%20works%21/#7-jangan-takut-kontes","title":"7 | Jangan Takut Kontes","text":"<p>\"Oke, untuk saat ini saya tidak berpartisipasi dalam kontes karena saya belum cukup baik, tapi saya akan berlatih dan bekerja keras, dan setelah beberapa saat saya akan mulai berpartisipasi dalam kontes.\"</p> <p>Itu bukan pendekatan yang baik. Seperti yang Anda lihat, saya juga berpartisipasi dalam semua kontes saat itu. Lihat juga bagian ini dari Alireza Avani, si alggo dari Iran. \"Ada juga pertanyaan lain dari Codeforces, dan bunyinya: 'Apa perbedaan yang kamu lakukan dibandingkan dengan orang lain yang kamu yakini memiliki efek signifikan pada peningkatanmu?'\"</p> <p>Alireza Avani menjawab, \"Saya selalu berusaha untuk tidak pernah melewatkan kontes di Codeforces. Tidak pernah melewatkan kontes. Saya tidak melewatkan satu pun kontes di tahun 2018 dan 2019.\"</p> <p>\"Wow! Kenapa? Bagaimana bisa?\"</p> <p>\"Karena saya sangat menikmatinya. Apakah kamu melewatkan janji kencan dengan kekasihmu? Tidak. Tidak.\"</p> <p>Jadi, di awal, sangat penting untuk berpartisipasi dalam semua kontes CF. Itu juga meningkatkan motivasi Anda, melihat rating naik dan turun sangat membantu. Jadi, cobalah untuk berpartisipasi dalam semua kontes yang ada. Jangan takut seperti, \"Ya ampun, saya akan kehilangan rating.\" Tidak apa-apa kehilangan rating, Anda akan naik kembali.</p> <p>Cobalah untuk berpartisipasi di semua kontes. Dan jika dalam sebuah kontes ada masalah yang Anda yakini seharusnya bisa Anda selesaikan tetapi Anda tidak berhasil, setelah kontes, habiskan lebih banyak waktu untuk itu. Kami menyebutnya upsolving, dan cobalah untuk upsolve masalah itu. Upsolving sangat membantu Anda untuk berkembang.</p> <p>Dan tidak hanya berpartisipasi dalam kontes, tetapi juga cobalah untuk melakukan virtual contests juga. Codeforces memiliki fitur ini yang disebut partisipasi virtual, di mana Anda bisa memilih kontes Codeforces mana pun, dan kemudian Anda bisa memulai kontes virtual. Jadi, itu akan persis seperti kontes CF normal. Anda akan menyelesaikan masalah, Anda tidak memiliki akses ke solusi atau apa pun. Ini seperti Anda benar-benar berpartisipasi dalam kontes CF, tetapi secara virtual. Kontesnya sudah lewat, tetapi Anda akan berpartisipasi di dalamnya dalam waktu terbatas itu dan Anda harus menyelesaikan masalahnya.</p> <p>Berpartisipasi dalam kontes virtual dan upsolving masalah yang belum Anda selesaikan selama kontes sangat membantu saya, jadi saya yakin itu juga akan sangat membantu Anda.</p>","tags":["advice"]},{"location":"deliberate-practice/From%20Newbie%20to%20Expert%20in%203%20Months%20-%20100%25%20works%21/#8-cara-melihat-tutorial-atau-membaca-kode-orang-lain","title":"8 | Cara Melihat Tutorial atau Membaca Kode Orang Lain","text":"<p>Nah, misalnya, pada masalah ini, Anda bisa menemukan editorial di sini. Juga, ketika saya menyiapkan editorial video untuk kontes Codeforces, Anda bisa menemukan editorial video dari saya juga di mana saya telah menjelaskan setiap masalah. Anda juga bisa melihat kode orang lain dengan mengklik tautan ini dan kemudian klik nomor ini, dan Anda akan memiliki akses ke kode setiap orang. Dan poin yang sangat bagus tentang itu adalah kode-kode ini diurutkan berdasarkan ukurannya, jadi kode pertama yang akan Anda lihat di sini adalah kode terkecil. Jadi, Anda bisa belajar banyak tentang cara menulis kode yang lebih pendek dan cara mengimplementasikannya dengan lebih baik, karena beberapa orang mungkin harus melakukan banyak pekerjaan untuk hal yang sama yang bisa dilakukan dengan kode yang lebih pendek.</p>","tags":["advice"]},{"location":"deliberate-practice/From%20Newbie%20to%20Expert%20in%203%20Months%20-%20100%25%20works%21/#kesimpulan","title":"Kesimpulan","text":"<p>Oke, teman-teman, itu saja dengan tujuh poin tentang cara menjadi expert. Ini adalah hal-hal yang saya lakukan sendiri juga, tentu saja kecuali menonton tutorial saya sendiri. Dan dalam kedua kasus, ketika saya melakukannya dan ketika saya menyuruh siswa-siswa saya untuk melakukan ini, itu selalu berhasil dengan baik dan orang-orang mengalami pertumbuhan besar dalam rating mereka. Saya tunjukkan lagi, Anda bisa melihat bahwa hanya dalam 3 bulan saya bisa mencapai ini, memiliki peringkat empat dalam kontes Codeforces saat saya seorang expert dari seorang newbie. Jadi, ketika itu berhasil untuk saya, itu pasti akan berhasil untuk Anda juga.</p> <p>Sekarang, saya punya tugas untuk Anda. Di kolom komentar di bawah, tuliskan keadaan Anda saat ini. Berapa rating Anda sekarang dan dalam berapa bulan Anda ingin menjadi expert? Dan ketika waktu itu telah berlalu, misalnya Anda mengatakan bahwa dalam 5 bulan saya akan menjadi expert, ketika 5 bulan berlalu, balas saja komentar itu dan katakan bagaimana Anda melakukan strategi ini dan bagaimana itu berhasil untuk Anda. Saya yakin jika Anda benar-benar melakukan strategi ini, Anda akan mencapai tujuan Anda.</p> <p>Itu saja. Saya harap video ini membantu Anda. Jika Anda belajar sesuatu dari video ini, silakan suka dan Anda juga sangat disambut untuk bergabung dengan komunitas kami dengan bergabung di saluran Telegram dan grup Telegram kami. Anda bisa menemukan tautannya di deskripsi di bawah. Sampai jumpa lain waktu, Shayan.</p>","tags":["advice"]},{"location":"deliberate-practice/Instead%2C%20Do%20These%21%20If%20you%20want%20to%20get%20out%20of%20Newbie.../","title":"Instead, Do These! If you want to get out of Newbie...","text":"<p>Link Sumber: Instead, Do These! If you want to get out of Newbie... - YouTube</p>","tags":["advice"]},{"location":"deliberate-practice/Instead%2C%20Do%20These%21%20If%20you%20want%20to%20get%20out%20of%20Newbie.../#instead-do-these-if-you-want-to-get-out-of-newbie","title":"Instead, Do These! If you want to get out of Newbie...","text":"<p>Halo semuanya, saya Shayan, dan hari ini saya akan berbicara tentang lima hal yang harus Anda lakukan untuk keluar dari tahap newbie.</p>","tags":["advice"]},{"location":"deliberate-practice/Instead%2C%20Do%20These%21%20If%20you%20want%20to%20get%20out%20of%20Newbie.../#1-selesaikan-banyak-masalah-dengan-kesulitan-rendah","title":"1 | Selesaikan Banyak Masalah dengan Kesulitan Rendah","text":"<p>Di problem set Codeforces, urutkan masalah berdasarkan kesulitan atau jumlah orang yang telah menyelesaikannya. Di problem set Codeforces, seperti yang bisa Anda lihat di sini, Anda bisa mengurutkan masalah berdasarkan kesulitannya atau jumlah orang yang telah menyelesaikannya. Misalnya, jika Anda klik di sini, itu akan mengurutkan masalah berdasarkan kesulitannya. Anda bisa lihat masalah pertama memiliki kesulitan 800, tetapi seiring Anda maju\u2014misalnya jika Anda membuka halaman, katakanlah halaman 15\u2014Anda bisa lihat kesulitannya meningkat. Anda juga bisa mengurutkan masalah berdasarkan jumlah orang yang telah menyelesaikannya.</p> <p>Jadi, urutkan masalah berdasarkan kesulitan atau jumlah orang yang telah menyelesaikannya dan mulailah menyelesaikan masalah dengan kesulitan terendah. Sangat penting untuk menyelesaikan banyak masalah.</p>","tags":["advice"]},{"location":"deliberate-practice/Instead%2C%20Do%20These%21%20If%20you%20want%20to%20get%20out%20of%20Newbie.../#2-selesaikan-masalah-dengan-tag-implementasi-brute-force-dan-matematika","title":"2 | Selesaikan Masalah dengan Tag Implementasi, Brute Force, dan Matematika","text":"<p>Tuliskan ketiga topik ini di suatu tempat: Implementasi, Brute Force, dan Matematika. Ini adalah tiga topik utama yang Anda harus bisa menyelesaikan masalah dengan tag ini. Sebagian besar masalah A dan B di kontes Divisi 2 atau Divisi 3 menggunakan tag ini. Jadi, cobalah untuk menyelesaikan masalah-masalah mudah dengan tag ini. Anda perlu fokus pada masalah-masalah ini agar dalam kontes Anda bisa dengan mudah menyelesaikannya, dan ini akan membantu rating Anda meningkat secara masif.</p>","tags":["advice"]},{"location":"deliberate-practice/Instead%2C%20Do%20These%21%20If%20you%20want%20to%20get%20out%20of%20Newbie.../#3-capai-sekitar-300-accept-di-codeforces","title":"3 | Capai Sekitar 300 Accept di Codeforces","text":"<p>Di Codeforces, sangat penting untuk menyelesaikan banyak masalah di awal perjalanan Anda. Jadi, seperti yang saya katakan, Anda harus mengurutkan masalah berdasarkan kesulitan dan bahkan memilih tag, lalu mulailah menyelesaikan banyak masalah. Anda harus mencapai 300 accept di Codeforces di awal. Ini adalah hal pertama yang harus Anda lakukan. Jangan fokus pada hal lain dan cobalah melakukan ini terlebih dahulu.</p>","tags":["advice"]},{"location":"deliberate-practice/Instead%2C%20Do%20These%21%20If%20you%20want%20to%20get%20out%20of%20Newbie.../#4-berpartisipasi-dalam-semua-kontes-cf-terutama-kontes-divisi-3","title":"4 | Berpartisipasi dalam Semua Kontes CF, Terutama Kontes Divisi 3","text":"<p>Ada keyakinan yang salah bahwa ketika Anda belum terlalu berpengalaman, Anda tidak boleh berpartisipasi dalam kontes CF. Orang-orang percaya bahwa, \"Oke, saya akan menunggu sampai saya menjadi lebih baik, saya menjadi lebih kuat, baru kemudian saya akan mulai berpartisipasi dalam kontes CF.\" Nah, ini salah. Berpartisipasi dalam kontes adalah untuk meningkatkan diri Anda, untuk berlatih.</p> <p>Jadi, jika Anda tidak berpartisipasi dalam kontes, Anda melewatkan salah satu cara untuk menjadi lebih baik. Jadi, pastikan untuk berpartisipasi dalam semua kontes CF, terutama kontes Divisi 3 yang khusus untuk para pemula. Di awal perjalanan Anda, pastikan untuk tidak melewatkan kontes CF.</p>","tags":["advice"]},{"location":"deliberate-practice/Instead%2C%20Do%20These%21%20If%20you%20want%20to%20get%20out%20of%20Newbie.../#5-baca-kode-orang-lain-setelah-anda-mendapatkan-accept-pada-sebuah-masalah","title":"5 | Baca Kode Orang Lain Setelah Anda Mendapatkan Accept pada Sebuah Masalah","text":"<p>Ini sangat penting. Setelah Anda menyelesaikan masalah dan mendapat accept, beberapa orang berpikir, \"Oke, saya selesai dengan masalah ini.\" Itu salah. Ketika Anda menyelesaikan masalah, sebagian besar dari peningkatan masih tersisa. Anda perlu membaca kode orang lain, Anda perlu melihat bagaimana orang lain mengimplementasikannya. Ini sangat penting. Saya sendiri belajar banyak dengan membaca kode orang lain.</p> <p>Dengan membaca kode, Anda bisa memahami bagaimana orang lain mengimplementasikan solusi, sehingga Anda mendapatkan ide tentang cara implementasi yang lebih baik. Anda bisa melihat bagaimana orang lain menyelesaikan masalah, mungkin solusi mereka benar-benar berbeda. Anda bisa melihat semua ini dengan membaca kode orang lain.</p> <p>Jadi, setelah itu, pastikan untuk memeriksa kode orang lain dan lihat apakah cara mereka berbeda dengan cara Anda mengimplementasikannya atau tidak. Jika berbeda, maka itu hal yang bagus, karena kamu bisa belajar dari mereka.</p> <p>...(video ini terputus di sini)</p> <p>Aku harap kalian yang menonton video ini sebagai newbie, suatu hari nanti bisa menjadi International Grandmaster dan saya juga memiliki banyak siswa yang berhasil keluar dari tahap newbie. Saya juga memiliki video bagus lain, jadi, jika Anda belum melihatnya, pastikan untuk menontonnya juga.</p> <p>Terima kasih! Shayan.</p>","tags":["advice"]},{"location":"deliberate-practice/Never%20Do%20these%21%20If%20you%20want%20to%20get%20out%20of%20Newbie/","title":"Never Do these! If you want to get out of Newbie","text":"<p>Link Sumber: Never Do these! If you want to get out of Newbie. - YouTube</p>","tags":["advice"]},{"location":"deliberate-practice/Never%20Do%20these%21%20If%20you%20want%20to%20get%20out%20of%20Newbie/#never-do-these-if-you-want-to-get-out-of-newbie","title":"Never Do these! If you want to get out of Newbie","text":"<p>Hai guys, aku akan memberikan tips dan trick ini, sebagai seseorang yang dulu juga adalah seorang newbie. Semua yang saya katakan, berdasarkan dari pengalaman saya sendiri. Jadi, perhatikan tips dan trick yang aku bagikan ini.</p>","tags":["advice"]},{"location":"deliberate-practice/Never%20Do%20these%21%20If%20you%20want%20to%20get%20out%20of%20Newbie/#1-jangan-memulai-dari-struktur-data-yang-rumit","title":"1 | Jangan Memulai dari Struktur Data yang Rumit","text":"<p>Ketika Anda berada di tahap Newbie, masalah utama yang perlu Anda selesaikan adalah masalah yang relatif mudah dibandingkan masalah lain. Jadi, Anda perlu fokus pada ini. Pertama, Anda harus menyelesaikan masalah ini, dan baru setelah itu Anda harus mempelajari struktur data lainnya. Anda perlu mulai menyelesaikan masalah implementasi, masalah brute force, masalah matematika, dll.</p> <p>Jadi, hal terburuk yang bisa Anda lakukan pada diri sendiri adalah mempelajari struktur data yang rumit yang tidak akan membantumu sama sekali. Kamu boleh mempelajarinya, tapi setelah levelmu sudah naik dan cukup tinggi.</p>","tags":["advice"]},{"location":"deliberate-practice/Never%20Do%20these%21%20If%20you%20want%20to%20get%20out%20of%20Newbie/#2-jangan-pecahkan-masalah-c-d-e","title":"2 | Jangan Pecahkan Masalah C, D, E, ...","text":"<p>Ketika Anda berada di tahap Newbie, Anda tidak boleh langsung pergi dan menyelesaikan masalah C, D, E, F, dll. Anda perlu fokus pada penyelesaian masalah A dan B maksimal. Karena inilah yang harus Anda tingkatkan dan kuasai sepenuhnya dalam kontes.</p> <p>Untuk memaksimalkan hasil, fokuslah terlebih dahulu pada problem-problem dengan level ini, jangan mencoba hal-hal yang lebih sulit dari level ini. </p> <p>Ingat ini, aku dulunya juga adalah seorang newbie, jadi aku tahu apa jalan yang harus dilalui dan dilewati. Semua yang aku katakan berdasakan dari pengalaman saya sendiri. </p>","tags":["advice"]},{"location":"deliberate-practice/Never%20Do%20these%21%20If%20you%20want%20to%20get%20out%20of%20Newbie/#3-jangan-berhenti-berpikir-jika-masih-memiliki-ide","title":"3 | Jangan Berhenti Berpikir Jika Masih Memiliki Ide","text":"<p>Ketika Anda merasa putus asa dalam menemukan jawaban, dan ada hal-hal yang belum Anda periksa, dan Anda merasa bisa memikirkannya, jangan berhenti berpikir. Jika Anda merasa mungkin memiliki beberapa ide, pikirkanlah. Jangan langsung melihat solusi masalah terlalu cepat, jangan pergi dan membaca editorial terlalu cepat.</p> <p>Jadi, jika Anda ingin menjadi lebih baik dan berkembang, selama Anda masih memiliki ide di kepala Anda, ada hal-hal yang menurut Anda harus diperiksa, pikirkanlah, dan cobalah menyelesaikannya terlebih dahulu. Dan jangan langsung melihat solusi masalah jika Anda masih yakin memiliki beberapa ide.</p>","tags":["advice"]},{"location":"deliberate-practice/Never%20Do%20these%21%20If%20you%20want%20to%20get%20out%20of%20Newbie/#4-jangan-berpikir-lebih-dari-yang-dibutuhkan","title":"4 | Jangan Berpikir Lebih dari yang Dibutuhkan","text":"<p>Meskipun saya mengatakan penting untuk berpikir seperlunya, Anda juga harus mempertimbangkan arah yang salah lainnya. Anda tidak boleh berpikir lebih dari yang dibutuhkan pada sebuah masalah. Jadi, jika Anda buntu pada sebuah masalah dan tidak punya ide lain, Anda bisa melihat solusinya. Anda bisa berhenti mencoba menyelesaikannya.</p> <p>Jangan lupakan bahwa jika Anda menginginkan efisiensi dalam cara Anda belajar, Anda harus tahu hal-hal apa yang tidak boleh Anda lakukan. Berpikir lebih dari yang dibutuhkan adalah salah satu hal yang tidak boleh Anda lakukan. Itu membuang-buang waktu. Jadi, jika Anda buntu, pergilah dan lihat solusinya. Tetapi jika ada hal-hal yang Anda pikir belum Anda periksa, Anda harus memeriksanya terlebih dahulu. Dan jika Anda melihat solusi masalah, pikirkan mengapa Anda bahkan tidak memikirkan ide-ide ini, mengapa Anda tidak pergi dan memeriksanya, mengapa Anda tidak memikirkan cara-cara spesifik ini dalam menyelesaikan masalah.</p>","tags":["advice"]},{"location":"deliberate-practice/Never%20Do%20these%21%20If%20you%20want%20to%20get%20out%20of%20Newbie/#5-jangan-menyerah","title":"5 | Jangan Menyerah","text":"<p>Dan yang paling penting adalah, jangan menyerah. Di masa-masa saya masih Newbie, saya tidak pernah merasa bahwa saya tidak cocok untuk ini, saya tidak bisa mempelajarinya, saya tidak bisa menjadi hebat dalam hal ini. Saya terus belajar, saya terus menyelesaikan masalah, melihat solusi orang lain, dll.</p> <p>Selain saya, ada juga orang lain yang telah melakukannya. Misalnya, Anda bisa lihat di sini grafik saya sendiri. Anda bisa lihat bahwa saya adalah Newbie pada periode ini, tetapi saya melanjutkan pertumbuhan dan saya mencapai titik ini. Saya mencapai International Grandmaster.</p> <p>![[Never Do these! If you want to get out of Newbie-1.png]]</p> <p>Ada orang lain juga. Misalnya, Anda bisa lihat di sini ada orang lain yang terjebak di tahap Newbie untuk waktu yang relatif lama. Tetapi akhirnya dia keluar dari sana, seperti yang bisa Anda lihat di sini, dan dia mencapai Expert, dan dia melakukannya dengan sangat cepat.</p> <p>![[Never Do these! If you want to get out of Newbie-2.png]]</p> <p>Contoh lain adalah akun ini. Anda bisa lihat dia juga berada di tahap Newbie untuk waktu yang relatif lama, terutama di sini dia mengikuti banyak kontes tetapi dia tetap menjadi seorang newbie. Hingga pada akhirnya ia bisa menjadi Candidate Master.</p> <p>![[Never Do these! If you want to get out of Newbie-3.png]]</p> <p>...contoh yang menarik adalah orang ini, Alireza Kaviani. Dia adalah seorang Newbie suatu hari, dan dia terjebak di sana, tetapi dia terus maju, dan dia belajar dan belajar, dia berlatih sangat keras. Dia menyelesaikan banyak masalah karena saya mengenalnya. Saya tahu seberapa besar usaha yang dia curahkan, dan akhirnya dia mencapai Legendary Grandmaster.</p> <p>![[Never Do these! If you want to get out of Newbie-4.png]]</p> <p>Jadi, mungkin saja hari ini Anda adalah seorang Newbie, tetapi suatu hari nanti Anda akan menjadi seorang Legendary Grandmaster. Jadi...  Jangan pernah menyerah!</p> <p>Jadi, berikut tips dan trick yang yang bisa saya bagikan, terima kasih, Shayan.</p>","tags":["advice"]}]}